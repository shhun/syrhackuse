#ifndef SPHERE_HPP
#define SPHERE_HPP

#include "vec3.hpp"
#include "ray.hpp"
#include "hit_record.hpp"
#include "cassert"
#include "cstdio"
#include "material.hpp"

struct Sphere {
  Vec3 center;
  double radius;
  Material material;

  Sphere(Vec3 center, double radius){
    this->center = center;
    this->radius = radius;
    this->material = Material();
  }

  Sphere(Vec3 center, double radius, Vec3 albedo){
    this->center = center;
    this->radius = radius;
    this->material = Material(albedo, false);
  }

  Sphere(Vec3 center, double radius, Material material){
    this->center = center;
    this->radius = radius;
    this->material = material;
  }

  bool hit(Ray ray, Hit_record &hr){
    // Returns true if the polynomial
    // equation 'ray.origin + t*ray in sphere'
    // has roots (ie: if the ray hits the sphere)
    Vec3 pos = ray.origin - this->center;

    double a = ray.direction * ray.direction;
    double b = pos * ray.direction;
    double c = pos * pos - this->radius * this->radius;
    // The polynomial is
    // a*t^2 + 2b*t + c

    // we divide the discriminant by 4
    // as this 4 will be simplified during
    // root computations
    double discriminant = b*b - a*c;

    if (discriminant >= 0){
      // compute the two roots of the polynomial
      // generated by the ray
      // Update hit_record with the closest root
      // that is in front of the camera
        
      double root_discriminant = sqrt(discriminant);
      double r1 = (-b + root_discriminant)/a;
      double r2 = (-b - root_discriminant)/a;
      
      // If there is a hit, take the closest one 
      // and update hit_record accordingly
      if (r2 > 0){
        hr.t = r2;
        hr.p = ray.point_at_parameter(hr.t);
        hr.normal = (hr.p - this->center).normalize();
        hr.material = this->material;

        return true;
      } else if (r1 > 0){
        hr.t = r1;
        hr.p = ray.point_at_parameter(hr.t);
        hr.normal = (hr.p - this->center).normalize();
        hr.material = this->material;

        return true;
      }
    }
    return false;
  }
};

#endif
